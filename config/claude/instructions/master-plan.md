# Master Plan Editing

**NEVER EXECUTE THE PLAN. ONLY EDIT IT.**

You are editing plan files. Your ONLY output is edits to those plans.

---

## The Rule

**Every action must result in plan file edits, not implementation.**

---

## Plan Directory Structure

Plans live in a `PLANS/` directory with this structure:

```
PLANS/
├── MASTER.md      # Full spec overview, links to scopes (read first)
├── LOG.md         # Append-only work log (read second)
├── QUESTIONS.md   # Open questions needing answers
├── DISCOVERIES.md # Important learnings, context, research
└── {SCOPE}.md     # Individual scope plans (MODELS.md, HANDLERS.md, etc.)
```

### File Roles

| File | Purpose |
|------|---------|
| **MASTER.md** | Entry point. Full detailed spec. Architecture, links to all scopes. Zero-to-hero in one read. |
| **LOG.md** | Append-only history. Read before work, append after. Breaks loops, provides memory. |
| **QUESTIONS.md** | Open questions needing resolution. Deferred questions land here. |
| **DISCOVERIES.md** | Research findings, blockers, context relevant to overall implementation. |
| **{SCOPE}.md** | Detailed plans for specific areas. MASTER links here. |

### LOG.md Rules

- **APPEND ONLY** - never edit existing entries
- Use unordered list (bullets) to avoid race conditions
- Multiple agents may work concurrently
- Read before starting work
- Append after completing work

**Format:** `**action(context)**: message` — Commit-message style. Brief but not cryptic.

```markdown
- **add(MASTER)**: rate limiting section
- **split(AUTH.md)**: separated permissions into own file for clearer ownership
- **update(DISCOVERIES)**: documented Redis vs Memcached tradeoffs from research
- **refine(MODELS)**: added field descriptions for NotificationPreference
```

### QUESTIONS.md Rules

Open questions that block progress or need user/research input.

**When asking user a question, always offer option to defer:**

> "Should we use Redis or Memcached for caching?"
> 1. Redis
> 2. Memcached
> 3. **Defer** — add to QUESTIONS.md for later

Deferred questions get added to QUESTIONS.md with context about why it matters.

**Format:**

```markdown
## Q: Redis vs Memcached for session caching?

**Context**: Auth system needs caching layer. Redis has persistence, Memcached is simpler.
**Added**: 2024-01-15

### Research Notes
(filled in by `/master-plan questions`)
```

---

## Subcommand: `/master-plan questions`

Resolves open questions through research and user input.

**Flow:**
1. Read QUESTIONS.md
2. For each question, spawn sub-agent to research (codebase, docs, web)
3. Sub-agents return findings → added to question's Research Notes
4. Main instance presents each question with research context
5. User answers or defers again
6. Resolved questions → update relevant plan files, remove from QUESTIONS.md
7. Log all changes

---

## Subcommand: `/master-plan finish`

Transitions plan from planning to implementation mode.

**Flow:**
1. **Remove disclaimers** - Strip all "NEVER EXECUTE" / "THIS IS A PLAN" language from MASTER.md
2. **Discover CLAUDE.md files** - Find all CLAUDE.md files in the project root and subdirectories. These contain project conventions that agents must follow.
3. **Scour for issues** - Scan ALL plan files for:
   - Unresolved questions (`?` in prose, items in QUESTIONS.md)
   - Ambiguous markers (`TODO:`, `TBD`, `UNKNOWN`, `???`)
   - Conflicting statements between scope files
4. **Resolve or abort** - Present any issues to user. Must resolve before proceeding.
5. **Truncate LOG.md** - Move existing content to `LOG_ARCHIVE.md`, start fresh with:
   ```
   - **finish**: transitioned to implementation mode
   ```
6. **Create IMPLEMENTATION.yaml** - State tracking for automation loop
7. **Add CLAUDE.md references to MASTER.md** - Include links to all discovered CLAUDE.md files so agents load them
8. **Prepend instructions to MASTER.md** - Implementation loop instructions block

---

### CLAUDE.md References Block

Added to MASTER.md during finish. Provides agents with project-specific conventions.

**Discovery:** Run `find . -name "CLAUDE.md" -type f` from project root.

**Template (adapt paths based on discovery):**

```markdown
### Project Instructions

Before implementing, read these project-specific instruction files:

| File | Purpose |
|------|---------|
| [CLAUDE.md](../CLAUDE.md) | Root project conventions, patterns, tech stack |
| [subdir/CLAUDE.md](../subdir/CLAUDE.md) | Subdirectory-specific conventions |

These files contain critical context that agents MUST follow during implementation.
```

**Rules:**
- Include ALL discovered CLAUDE.md files
- Paths should be relative from PLANS/ directory
- Add brief purpose description for each (infer from location or file content)

---

### IMPLEMENTATION.yaml

Created in PLANS/ directory. Tracks state for each scope file.

```yaml
# Auto-generated by /master-plan finish
# Updated by implementation loop - do not edit manually

scopes:
  MODELS.md:
    status: pending    # pending | in_progress | done | ISSUE
    attempts: 0
    issue: null

  HANDLERS.md:
    status: pending
    attempts: 0
    issue: null

  # ... one entry per scope file
```

---

### Implementation Instructions Block

Prepended to MASTER.md (replaces the disclaimer block):

```markdown
---
## IMPLEMENTATION MODE

This plan is being implemented via automated loop.

### Your Task

You are tasked with finding and completing **1 TASK ONLY**.

### Before Acting

1. **Read MASTER.md** - This file contains the full plan context and these instructions
2. **Read IMPLEMENTATION.yaml** - Check current state of all scopes
3. **Read LOG.md** - Understand recent context and what's happened
4. **Read CLAUDE.md files** - Load project-specific instructions from ALL CLAUDE.md files in the workspace (root and subdirectories). Check the "Project Instructions" section in this file for links. These contain critical project conventions.
5. **Check git log** - Review recent commits to verify past agents followed instructions
6. **Handle uncommitted files** - If any exist, commit them with appropriate message before proceeding
7. **Select ONE pending scope** - Pick a scope with `status: pending`

### Execution

1. **Evaluate scope size** - If too large to complete in one pass:
   - Break it into smaller scope files
   - Add new entries to IMPLEMENTATION.yaml
   - Log: `- **split(SCOPE)**: broke into X smaller scopes`
   - Commit: `split(SCOPE): broke into X smaller scopes`
   - Return `<TASK COMPLETE>`

2. **Implement the scope** - Complete the work described in the scope file

3. **Log your work** - Append to LOG.md (detailed notes):
   ```
   - **implement(SCOPE)**: what you did, files changed, decisions made
   ```

4. **Commit your work** - Create clean commit (brief message):
   ```
   implement(SCOPE): concise summary
   ```
   Do NOT push. Just commit to current branch.

5. **Verify BEFORE marking done** - Re-read the scope file and verify ALL items are FULLY implemented:
   - Check every bullet point, requirement, and acceptance criteria
   - If ANY part is not implemented, set `status: in_progress` NOT `done`
   - Only set `status: done` when 100% of the scope is complete

6. **Update state** - Set status in IMPLEMENTATION.yaml based on verification above

### Git Discipline

- **Commit after each task** — One scope = one commit
- **Clean commit messages** — `action(scope): brief summary` format
- **LOG.md has details** — Commit messages stay short, LOG.md has full context
- **Never push** — Commits stay local for human review
- **Verify history** — Check recent commits show proper patterns from past agents
- **Resolve orphaned work** — Uncommitted changes from crashed agents should be committed with `recover(SCOPE): description`

### Error Handling

If implementation fails:
1. Log attempt: `- **attempt(SCOPE)**: what went wrong`
2. Commit attempt: `attempt(SCOPE): what went wrong`
3. Increment `attempts` in IMPLEMENTATION.yaml
4. If `attempts > 3`:
   - Set `status: ISSUE`
   - Set `issue: "description of the problem"`
5. Move on to other pending tasks

### Completion Signals

Return EXACTLY one of these at the end of your response:

- `<TASK COMPLETE>` — You completed (or split) one scope, more work remains
- `<ALL TASKS DONE TO BEST OF ABILITY>` — All scopes are `done` or `ISSUE`, nothing left to do

### Rules

- **ONE TASK ONLY** — Never attempt multiple scopes in one pass
- **CHECK LOG FIRST** — Always read LOG.md before acting
- **CHECK GIT LOG** — Verify past agents committed properly
- **LOG EVERYTHING** — All actions must be traceable in LOG.md
- **COMMIT EVERYTHING** — All actions must have a commit (clean history)
- **SKIP ISSUE TASKS** — Don't retry scopes with 3+ failed attempts
- **BE EXPLICIT** — End with a completion signal, always
- **FULL STACK** — This is a full-stack project. You implement BOTH backend AND frontend. Never mark a scope "not in scope" because it involves frontend or a different layer.
- **NO "NOT IN SCOPE" EXCUSES** — Every scope must be fully implemented. You cannot mark a task done by claiming parts are "not in scope", "frontend-only", "lives elsewhere", or "already handled by API". If the scope describes it, you implement it.
- **VERIFY BEFORE DONE** — Re-read the scope file before marking done. If ANY item remains unimplemented, status is `in_progress`, not `done`.
---
```

---

## Plan Structure

Plans are broken into **scopes** — logical chunks that one person can pick up and complete.

Each scope file should be:
- **Self-contained**: All context needed to implement
- **Clear on boundaries**: What's in scope, what's not
- **Detailed enough**: No ambiguity about what to build

MASTER.md links to all scopes and provides the full picture. Scope files provide implementation detail.

**Example MASTER.md structure:**

```markdown
## Scopes

| Scope | Description |
|-------|-------------|
| [MODELS.md](./MODELS.md) | Database models and enums |
| [HANDLERS.md](./HANDLERS.md) | API endpoint handlers |
| [SERVICES.md](./SERVICES.md) | Business logic layer |
```

No ordering implied. A person picks a scope, does it, reports back.

---

## Allowed

- Read code to understand context
- Search codebase for patterns
- Ask clarifying questions
- Edit plan files in PLANS/

## NEVER

- Edit any code files
- Run bash commands
- Start implementing tasks from the plan
- Create new files outside PLANS/
- "Just quickly fix" anything

---

## Workflow

1. Find PLANS/ directory (or create structure if starting fresh)
2. Read MASTER.md (overview)
3. Read LOG.md (current state)
4. Understand what needs refinement
5. Edit the appropriate plan file
6. Append to LOG.md what you did
7. Done. No implementation.

**IMPORTANT**: If any edit is made to any plan file, LOG.md must be updated.

---

## Context Drift Check

Before any action, ask: "Does this edit a plan file?"

- Yes → proceed
- No → stop, refocus

---

## Refusing Implementation Requests

If asked to "just implement this one thing":

> I'm in plan-editing mode. My job is to refine these plan documents, not implement them.
> Want me to add implementation notes to the plan instead?

---

## What Goes in MASTER.md

- Problem statement / overview
- Architecture diagram (text)
- Quick links table to all scope files
- File structure (target state)
- Technical decisions and rationale

Top and bottom should have:

```markdown
**IMPORTANT: NEVER EXECUTE THIS PLAN**
**THIS PLAN IS MASTER PLAN FOR BLUEPRINT DESIGN SPEC**
**THIS WARNING WILL BE REMOVED WHEN READY TO IMPLEMENT**
```

---

## Implementation Loop

After running `/master-plan finish`, use ralph to implement:

```bash
cd /path/to/project  # must have PLANS/ directory
ralph                # default 50 passes
ralph 100            # custom max passes
```

---

**NEVER EXECUTE THE PLAN. ONLY EDIT IT.**
