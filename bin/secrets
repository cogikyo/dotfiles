#!/usr/bin/env bash
# secrets - Manage age-encrypted secrets in dotfiles
#
# Uses recipient-based encryption with a passphrase-protected identity.
# Identity is encrypted with native age passphrase mode.
# Secrets are encrypted with age recipient key.
# Decrypting prompts for the identity passphrase once.
#
# Usage:
#   secrets init                  Generate identity (one-time)
#   secrets sync                  Encrypt all manifest targets into repo
#   secrets decrypt               Decrypt all to target paths
#   secrets trust                 Trust current manifest entries on this machine
#   secrets auth                  Generate Bitwarden 2FA code (emergency)
#   secrets list                  Show manifest entries
#   secrets --help                Show usage

set -euo pipefail
umask 077

DOTFILES="${DOTFILES:-$HOME/dotfiles}"
SECRETS_DIR="$DOTFILES/etc/secrets"
MANIFEST="$SECRETS_DIR/manifest"
IDENTITY="$SECRETS_DIR/identity.age"
LEGACY_IDENTITY="$SECRETS_DIR/identity.enc"
RECIPIENT="$SECRETS_DIR/recipient.txt"
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/dotfiles"
APPROVED_MANIFEST="$STATE_DIR/secrets-manifest.approved"

# passphrase policy reminder (native age prompt cannot be non-interactive)
MIN_PASSPHRASE_WORDS=12

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m'

info()    { printf '%b==>%b %s\n' "$BLUE" "$NC" "$*"; }
success() { printf '%b==>%b %s\n' "$GREEN" "$NC" "$*"; }
warn()    { printf '%b==>%b %s\n' "$YELLOW" "$NC" "$*"; }
error()   { printf '%b==>%b %s\n' "$RED" "$NC" "$*" >&2; }

has() { command -v "$1" &>/dev/null; }

IDENTITY_KEY=""
INIT_TMPKEY=""
TMP_OUT=""

cleanup() {
    local file
    for file in "${IDENTITY_KEY:-}" "${INIT_TMPKEY:-}" "${TMP_OUT:-}"; do
        [[ -n "$file" ]] && rm -f -- "$file"
    done
    return 0
}
trap cleanup EXIT INT TERM

require_age() {
    has age || { error "age not found — install with: pacman -S age"; exit 1; }
}

require_age_keygen() {
    has age-keygen || { error "age-keygen not found — install with: pacman -S age"; exit 1; }
}

require_recipient() {
    [[ -f "$RECIPIENT" ]] || { error "No recipient key — run: secrets init"; exit 1; }
}

expand() { echo "${1/#\~/$HOME}"; }

is_target_within_home() {
    has realpath || { error "realpath not found — install with: pacman -S coreutils"; exit 1; }

    local expanded="$1"
    local home_real target_real
    home_real=$(realpath -m -- "$HOME")
    target_real=$(realpath -m -- "$expanded")

    [[ "$target_real" == "$home_real" || "$target_real" == "$home_real/"* ]]
}

validate_entry() {
    local name="$1"
    local target="$2"
    local perms="$3"
    local expanded="$4"

    if [[ -z "$name" || -z "$target" || -z "$perms" ]]; then
        error "Invalid manifest entry: expected name:target:mode"
        return 1
    fi

    if [[ ! "$name" =~ ^[A-Za-z0-9._-]+$ ]]; then
        error "Invalid secret name '$name' (allowed: letters, numbers, ., _, -)"
        return 1
    fi

    if [[ ! "$perms" =~ ^[0-7]{3,4}$ ]]; then
        error "Invalid mode '$perms' for '$name' (expected octal like 600 or 0644)"
        return 1
    fi

    if ! is_target_within_home "$expanded"; then
        error "Refusing target outside HOME for '$name': $target"
        return 1
    fi
}

# Decrypt identity.age to a temp file using native age passphrase mode.
# Sets IDENTITY_KEY.
unlock_identity() {
    if [[ ! -f "$IDENTITY" ]]; then
        if [[ -f "$LEGACY_IDENTITY" ]]; then
            error "Found legacy identity.enc. Migrate with: secrets init && secrets sync"
        else
            error "No identity file — run: secrets init"
        fi
        exit 1
    fi

    IDENTITY_KEY=$(mktemp)

    if [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        warn "AGE_PASSPHRASE is ignored in native age mode (interactive prompt required)"
    fi

    if ! age -d -o "$IDENTITY_KEY" "$IDENTITY" 2>/dev/null; then
        rm -f "$IDENTITY_KEY"
        IDENTITY_KEY=""
        error "Failed to unlock identity (wrong passphrase?)"
        exit 1
    fi

    if ! grep -q 'AGE-SECRET-KEY' "$IDENTITY_KEY" 2>/dev/null; then
        rm -f "$IDENTITY_KEY"
        IDENTITY_KEY=""
        error "Decrypted identity is invalid"
        exit 1
    fi
}

parse_manifest() {
    [[ -f "$MANIFEST" ]] || return 0
    while IFS= read -r line; do
        [[ -z "$line" || "$line" == \#* ]] && continue
        echo "$line"
    done < "$MANIFEST"
    return 0
}

ensure_state_dir() {
    mkdir -p "$STATE_DIR"
    chmod 700 "$STATE_DIR"
}

is_entry_approved() {
    local entry="$1"
    grep -Fxq -- "$entry" "$APPROVED_MANIFEST" 2>/dev/null
}

trust_entries() {
    ensure_state_dir

    local tmp
    tmp=$(mktemp)

    {
        [[ -f "$APPROVED_MANIFEST" ]] && cat "$APPROVED_MANIFEST"
        printf '%s\n' "$@"
    } | awk 'NF' | sort -u > "$tmp"

    mv -f "$tmp" "$APPROVED_MANIFEST"
    chmod 600 "$APPROVED_MANIFEST"
}

review_untrusted_entries() {
    local entries="$1"
    local action="$2"
    local -a untrusted=()
    local entry

    while IFS= read -r entry; do
        [[ -z "$entry" ]] && continue
        if ! is_entry_approved "$entry"; then
            untrusted+=("$entry")
        fi
    done <<< "$entries"

    [[ ${#untrusted[@]} -eq 0 ]] && return 0

    warn "Found ${#untrusted[@]} new or changed manifest entr$( [[ ${#untrusted[@]} -eq 1 ]] && echo "y" || echo "ies" ):"
    printf '%-20s %-40s %s\n' "NAME" "TARGET" "MODE"
    printf '%-20s %-40s %s\n' "----" "------" "----"
    for entry in "${untrusted[@]}"; do
        local name target perms
        IFS=':' read -r name target perms <<< "$entry"
        printf '%-20s %-40s %s\n' "$name" "$target" "$perms"
    done
    echo

    if [[ ! -t 0 ]]; then
        error "Non-interactive session cannot approve new manifest entries"
        error "Run: secrets trust"
        return 1
    fi

    read -rp "Trust these entries on this machine and continue $action? [y/N] " yn
    if [[ ! "$yn" =~ ^[Yy]$ ]]; then
        error "Aborted due to untrusted manifest entries"
        return 1
    fi

    trust_entries "${untrusted[@]}"
    success "Trusted ${#untrusted[@]} manifest entr$( [[ ${#untrusted[@]} -eq 1 ]] && echo "y" || echo "ies" )"
}

# ── Commands ────────────────────────────────────────────────────────────────

cmd_init() {
    require_age
    require_age_keygen
    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    if [[ -f "$IDENTITY" ]]; then
        warn "Identity already exists"
        read -rp "Regenerate? This will require re-syncing all secrets [y/N] " yn
        [[ "$yn" =~ ^[Yy] ]] || return 0
    fi

    if [[ -f "$LEGACY_IDENTITY" ]]; then
        warn "Legacy identity.enc exists; native identity.age will be created"
    fi

    # Generate age identity
    INIT_TMPKEY=$(mktemp)
    rm -f "$INIT_TMPKEY"

    info "Generating age identity..."
    if ! age-keygen -o "$INIT_TMPKEY" 2>/dev/null; then
        error "Failed to generate age identity"
        return 1
    fi

    local pubkey
    pubkey=$(grep -o 'age1.*' "$INIT_TMPKEY")
    echo "$pubkey" > "$RECIPIENT"
    chmod 644 "$RECIPIENT"

    info "Encrypting identity with age passphrase prompt (use at least $MIN_PASSPHRASE_WORDS words)..."
    if ! age --passphrase -o "$IDENTITY" "$INIT_TMPKEY"; then
        rm -f "$IDENTITY" "$RECIPIENT"
        error "Failed to encrypt identity"
        return 1
    fi
    chmod 600 "$IDENTITY"

    rm -f "$INIT_TMPKEY"
    INIT_TMPKEY=""

    echo
    success "Identity created"
    info "Recipient: $pubkey"
}

cmd_sync() {
    local force=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=1 ;;
            -h|--help)
                cat <<'EOF'
Usage: secrets sync [--force]

Options:
    -f, --force     Re-encrypt all manifest secrets even if ciphertext is newer than source
EOF
                return 0
                ;;
            *)
                error "Unknown option for sync: $1"
                return 1
                ;;
        esac
        shift
    done

    require_age
    require_recipient

    local entries
    entries=$(parse_manifest)
    if [[ -z "$entries" ]]; then
        warn "Manifest is empty — add entries to secrets/manifest"
        return 0
    fi

    review_untrusted_entries "$entries" "sync" || return 1

    local synced=0 skipped=0 missing=0 invalid=0

    while IFS=':' read -r name target perms; do
        local expanded
        expanded=$(expand "$target")

        if ! validate_entry "$name" "$target" "$perms" "$expanded"; then
            ((invalid++)) || true
            continue
        fi

        local age_file="$SECRETS_DIR/$name.age"

        if [[ ! -f "$expanded" ]]; then
            warn "Not found: $target (skipping $name)"
            ((missing++)) || true
            continue
        fi

        # Skip if .age file is newer than source (unless forced)
        if [[ $force -eq 0 && -f "$age_file" && "$age_file" -nt "$expanded" ]]; then
            ((skipped++)) || true
            continue
        fi

        info "Encrypting $name ← $target"
        age -R "$RECIPIENT" -o "$age_file" "$expanded"
        chmod 600 "$age_file"
        ((synced++)) || true
    done <<< "$entries"

    echo
    if [[ $invalid -eq 0 && $missing -eq 0 ]]; then
        success "Synced $synced, unchanged $skipped"
    else
        warn "Synced $synced, unchanged $skipped, missing $missing"
    fi

    if [[ $invalid -ne 0 ]]; then
        error "Rejected $invalid invalid manifest entr$( [[ $invalid -eq 1 ]] && echo "y" || echo "ies" )"
        return 1
    fi
}

cmd_decrypt() {
    local dry_run=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n) dry_run=1 ;;
            -h|--help)
                cat <<'EOF'
Usage: secrets decrypt [--dry-run]

Options:
    -n, --dry-run   Verify that all encrypted secrets can be decrypted, without writing files
EOF
                return 0
                ;;
            *)
                error "Unknown option for decrypt: $1"
                return 1
                ;;
        esac
        shift
    done

    require_age

    local entries
    entries=$(parse_manifest)
    if [[ -z "$entries" ]]; then
        warn "Manifest is empty"
        return 0
    fi

    if [[ $dry_run -eq 1 ]]; then
        warn "Dry run mode enabled: verifying decryptability only (no files will be written)"
    fi

    review_untrusted_entries "$entries" "decrypt" || return 1

    unlock_identity

    local count=0 failed=0

    while IFS=':' read -r name target perms; do
        local age_file="$SECRETS_DIR/$name.age"
        local expanded
        expanded=$(expand "$target")

        if ! validate_entry "$name" "$target" "$perms" "$expanded"; then
            ((failed++)) || true
            continue
        fi

        if [[ ! -f "$age_file" ]]; then
            error "Missing: secrets/$name.age (skipping)"
            ((failed++)) || true
            continue
        fi

        if [[ $dry_run -eq 1 ]]; then
            info "Verifying $name (dry-run)"
            if age -d -i "$IDENTITY_KEY" "$age_file" >/dev/null 2>/dev/null; then
                ((count++)) || true
            else
                error "Failed to decrypt $name"
                ((failed++)) || true
            fi
            continue
        fi

        local target_dir
        target_dir=$(dirname "$expanded")
        mkdir -p "$target_dir"
        if [[ "$target_dir" == "$HOME/.ssh" ]]; then
            chmod 700 "$target_dir"
        fi

        local tmp_out
        tmp_out=$(mktemp "$target_dir/.${name}.tmp.XXXXXX")
        TMP_OUT="$tmp_out"

        info "Decrypting $name → $target"
        if age -d -i "$IDENTITY_KEY" -o "$tmp_out" "$age_file" 2>/dev/null; then
            chmod "$perms" "$tmp_out"
            mv -f "$tmp_out" "$expanded"
            TMP_OUT=""
            ((count++)) || true
        else
            rm -f "$tmp_out"
            TMP_OUT=""
            error "Failed to decrypt $name"
            ((failed++)) || true
        fi
    done <<< "$entries"

    echo
    if [[ $failed -eq 0 ]]; then
        if [[ $dry_run -eq 1 ]]; then
            success "Dry-run verified $count secrets"
        else
            success "Decrypted $count secrets"
        fi
    else
        if [[ $dry_run -eq 1 ]]; then
            warn "Dry-run verified $count, failed $failed"
        else
            warn "Decrypted $count, failed $failed"
        fi
        return 1
    fi
}

cmd_trust() {
    local entries
    entries=$(parse_manifest)
    if [[ -z "$entries" ]]; then
        warn "Manifest is empty"
        return 0
    fi

    local -a valid_entries=()
    local invalid=0

    while IFS=':' read -r name target perms; do
        local expanded
        expanded=$(expand "$target")
        if validate_entry "$name" "$target" "$perms" "$expanded"; then
            valid_entries+=("$name:$target:$perms")
        else
            ((invalid++)) || true
        fi
    done <<< "$entries"

    if [[ ${#valid_entries[@]} -eq 0 ]]; then
        error "No valid manifest entries to trust"
        return 1
    fi

    trust_entries "${valid_entries[@]}"
    success "Trusted ${#valid_entries[@]} manifest entr$( [[ ${#valid_entries[@]} -eq 1 ]] && echo "y" || echo "ies" ) for this machine"

    if [[ $invalid -ne 0 ]]; then
        warn "Skipped $invalid invalid manifest entr$( [[ $invalid -eq 1 ]] && echo "y" || echo "ies" )"
        return 1
    fi
}

cmd_passphrase() {
    local wordlist="/usr/share/dict/words"
    [[ -f "$wordlist" ]] || { error "No wordlist — install with: pacman -S words"; exit 1; }
    grep -E '^[a-z]{4,8}$' "$wordlist" | shuf -n "$MIN_PASSPHRASE_WORDS" | paste -sd' '
}

cmd_auth() {
    has oathtool || { error "oathtool not found — install with: pacman -S oath-toolkit"; exit 1; }

    local auth_dir="$HOME/.auth"
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        # List available auth entries
        local found=0
        for f in "$auth_dir"/*; do
            [[ -f "$f" ]] || continue
            printf '  %s\n' "${f##*/}"
            found=1
        done
        if [[ $found -eq 0 ]]; then
            warn "No auth entries in ~/.auth/"
        else
            info "Usage: secrets auth <name>"
        fi
        return 0
    fi

    local seed_file="$auth_dir/$name"
    [[ -f "$seed_file" ]] || { error "Not found: ~/.auth/$name"; exit 1; }

    # Keep the secret out of argv; read it from stdin instead.
    oathtool --totp -b - < "$seed_file"
}

cmd_list() {
    if [[ ! -f "$MANIFEST" ]]; then
        warn "No manifest found"
        return 0
    fi

    printf '%-20s %-40s %s\n' "NAME" "TARGET" "MODE"
    printf '%-20s %-40s %s\n' "----" "------" "----"

    while IFS=':' read -r name target perms; do
        local age_file="$SECRETS_DIR/$name.age"
        local marker="  "
        [[ ! -f "$age_file" ]] && marker="!!"
        printf '%s %-18s %-40s %s\n' "$marker" "$name" "$target" "$perms"
    done < <(parse_manifest)

    local auth_dir="$HOME/.auth"
    local auth_found=0
    for f in "$auth_dir"/*; do
        [[ -f "$f" ]] || continue
        if [[ $auth_found -eq 0 ]]; then
            echo
            printf '%-20s\n' "AUTH"
            printf '%-20s\n' "----"
            auth_found=1
        fi
        printf '   %-18s\n' "${f##*/}"
    done

    return 0
}

# ── Main ────────────────────────────────────────────────────────────────────

usage() {
    cat <<'EOF'
Usage: secrets <command> [args...]

Manage age-encrypted secrets in the dotfiles repo.
Uses recipient-based encryption with native age passphrase-wrapped identity.

Commands:
    init        Generate passphrase-protected identity (one-time)
    sync        Encrypt all manifest secrets into the repo (use --force to re-encrypt all)
    decrypt     Decrypt all secrets to target paths (or --dry-run to verify only)
    trust       Trust current manifest entries on this machine
    passphrase  Generate a random passphrase (offline, from /usr/share/dict/words)
    auth NAME   Generate TOTP code from ~/.auth/ entry
    list        Show all secrets and their status
    -h, --help  Show this help

Setup:
    secrets init           # create identity, set passphrase
    secrets trust          # trust current manifest entries locally
    secrets sync           # encrypt everything in the manifest
    secrets sync --force   # re-encrypt all entries (ignore timestamp optimization)

New machine:
    secrets decrypt        # unlock all secrets with passphrase
    secrets auth bitwarden # generate TOTP code for bitwarden
EOF
}

main() {
    case "${1:-}" in
        init)       cmd_init ;;
        sync)       shift; cmd_sync "$@" ;;
        decrypt)    shift; cmd_decrypt "$@" ;;
        trust)      cmd_trust ;;
        passphrase) cmd_passphrase ;;
        auth)       shift; cmd_auth "$@" ;;
        list)       cmd_list ;;
        -h|--help)  usage ;;
        "")         usage ;;
        *)          error "Unknown command: $1"; usage; exit 1 ;;
    esac
}

main "$@"
