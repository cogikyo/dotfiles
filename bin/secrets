#!/usr/bin/env bash
# secrets - Manage age-encrypted secrets in dotfiles
#
# Uses recipient-based encryption with a passphrase-protected identity.
# Identity is encrypted with openssl (accepts piped passphrases).
# Secrets are encrypted with age recipient key (no passphrase needed).
# Decrypting needs the passphrase to unlock the identity.
#
# Usage:
#   secrets init                  Generate identity (one-time)
#   secrets sync                  Encrypt all manifest targets into repo
#   secrets decrypt               Decrypt all to target paths
#   secrets auth                  Generate Bitwarden 2FA code (emergency)
#   secrets list                  Show manifest entries
#   secrets --help                Show usage

set -euo pipefail

DOTFILES="${DOTFILES:-$HOME/dotfiles}"
SECRETS_DIR="$DOTFILES/secrets"
MANIFEST="$SECRETS_DIR/manifest"
IDENTITY="$SECRETS_DIR/identity.enc"
RECIPIENT="$SECRETS_DIR/recipient.txt"

# openssl parameters for identity encryption
CIPHER="aes-256-cbc"
KDF_ITER=600000

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m'

info()    { printf '%b==>%b %s\n' "$BLUE" "$NC" "$*"; }
success() { printf '%b==>%b %s\n' "$GREEN" "$NC" "$*"; }
warn()    { printf '%b==>%b %s\n' "$YELLOW" "$NC" "$*"; }
error()   { printf '%b==>%b %s\n' "$RED" "$NC" "$*" >&2; }

has() { command -v "$1" &>/dev/null; }

require_age() {
    has age || { error "age not found — install with: pacman -S age"; exit 1; }
}

require_recipient() {
    [[ -f "$RECIPIENT" ]] || { error "No recipient key — run: secrets init"; exit 1; }
}

expand() { echo "${1/#\~/$HOME}"; }

# Decrypt identity to a temp file using openssl. Sets IDENTITY_KEY.
unlock_identity() {
    [[ -f "$IDENTITY" ]] || { error "No identity file — run: secrets init"; exit 1; }

    IDENTITY_KEY=$(mktemp)
    trap 'rm -f "$IDENTITY_KEY"' EXIT

    local pass
    if [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        pass="$AGE_PASSPHRASE"
    else
        read -rsp "Passphrase: " pass
        echo
    fi

    if ! echo "$pass" | openssl enc -d -"$CIPHER" -pbkdf2 -iter "$KDF_ITER" \
        -pass stdin -in "$IDENTITY" -out "$IDENTITY_KEY" 2>/dev/null; then
        rm -f "$IDENTITY_KEY"
        error "Failed to unlock identity (wrong passphrase?)"
        exit 1
    fi

    if ! grep -q 'AGE-SECRET-KEY' "$IDENTITY_KEY" 2>/dev/null; then
        rm -f "$IDENTITY_KEY"
        error "Decrypted identity is invalid"
        exit 1
    fi
}

parse_manifest() {
    [[ -f "$MANIFEST" ]] || return
    while IFS= read -r line; do
        [[ -z "$line" || "$line" == \#* ]] && continue
        echo "$line"
    done < "$MANIFEST"
}

# ── Commands ────────────────────────────────────────────────────────────────

cmd_init() {
    require_age
    mkdir -p "$SECRETS_DIR"

    if [[ -f "$IDENTITY" ]]; then
        warn "Identity already exists"
        read -rp "Regenerate? This will require re-syncing all secrets [y/N] " yn
        [[ "$yn" =~ ^[Yy] ]] || return 0
    fi

    # Read and validate passphrase
    local passphrase confirm
    read -rsp "Choose passphrase (12+ words recommended): " passphrase
    echo
    local word_count
    word_count=$(echo "$passphrase" | wc -w)
    if (( word_count < 12 )); then
        warn "Only $word_count words — 12+ recommended"
        read -rp "Continue anyway? [y/N] " yn
        [[ "$yn" =~ ^[Yy] ]] || return 1
    fi
    read -rsp "Confirm passphrase: " confirm
    echo
    if [[ "$passphrase" != "$confirm" ]]; then
        error "Passphrases don't match"
        return 1
    fi

    # Generate age identity
    INIT_TMPKEY=$(mktemp)
    rm -f "$INIT_TMPKEY"
    trap 'rm -f "$INIT_TMPKEY"' EXIT

    info "Generating age identity..."
    if ! age-keygen -o "$INIT_TMPKEY" 2>/dev/null; then
        error "Failed to generate age identity"
        return 1
    fi

    local pubkey
    pubkey=$(grep -o 'age1.*' "$INIT_TMPKEY")
    echo "$pubkey" > "$RECIPIENT"

    # Encrypt identity with passphrase via openssl
    info "Encrypting identity..."
    echo "$passphrase" | openssl enc -"$CIPHER" -pbkdf2 -iter "$KDF_ITER" -salt \
        -pass stdin -in "$INIT_TMPKEY" -out "$IDENTITY"

    # Verify round-trip
    local verify
    verify=$(mktemp)
    if echo "$passphrase" | openssl enc -d -"$CIPHER" -pbkdf2 -iter "$KDF_ITER" \
        -pass stdin -in "$IDENTITY" -out "$verify" 2>/dev/null && \
        grep -q 'AGE-SECRET-KEY' "$verify"; then
        rm -f "$verify"
    else
        rm -f "$verify" "$IDENTITY" "$RECIPIENT"
        error "Identity verification failed"
        return 1
    fi

    rm -f "$INIT_TMPKEY"
    trap - EXIT

    echo
    success "Identity created"
    info "Recipient: $pubkey"
}

cmd_sync() {
    require_age
    require_recipient

    local entries
    entries=$(parse_manifest)
    if [[ -z "$entries" ]]; then
        warn "Manifest is empty — add entries to secrets/manifest"
        return 0
    fi

    local synced=0 skipped=0 missing=0

    while IFS=':' read -r name target perms; do
        local expanded
        expanded=$(expand "$target")
        local age_file="$SECRETS_DIR/$name.age"

        if [[ ! -f "$expanded" ]]; then
            warn "Not found: $target (skipping $name)"
            ((missing++)) || true
            continue
        fi

        # Skip if .age file is newer than source
        if [[ -f "$age_file" && "$age_file" -nt "$expanded" ]]; then
            ((skipped++)) || true
            continue
        fi

        info "Encrypting $name ← $target"
        age -R "$RECIPIENT" -o "$age_file" "$expanded"
        ((synced++)) || true
    done <<< "$entries"

    echo
    if [[ $missing -eq 0 ]]; then
        success "Synced $synced, unchanged $skipped"
    else
        warn "Synced $synced, unchanged $skipped, missing $missing"
    fi
}

cmd_decrypt() {
    require_age

    local entries
    entries=$(parse_manifest)
    if [[ -z "$entries" ]]; then
        warn "Manifest is empty"
        return 0
    fi

    unlock_identity

    local count=0 failed=0

    while IFS=':' read -r name target perms; do
        local age_file="$SECRETS_DIR/$name.age"
        local expanded
        expanded=$(expand "$target")

        if [[ ! -f "$age_file" ]]; then
            error "Missing: secrets/$name.age (skipping)"
            ((failed++)) || true
            continue
        fi

        mkdir -p "$(dirname "$expanded")"

        info "Decrypting $name → $target"
        if age -d -i "$IDENTITY_KEY" -o "$expanded" "$age_file" 2>/dev/null; then
            chmod "$perms" "$expanded"
            ((count++)) || true
        else
            error "Failed to decrypt $name"
            ((failed++)) || true
        fi
    done <<< "$entries"

    echo
    if [[ $failed -eq 0 ]]; then
        success "Decrypted $count secrets"
    else
        warn "Decrypted $count, failed $failed"
        return 1
    fi
}

cmd_auth() {
    require_age
    has oathtool || { error "oathtool not found — install with: pacman -S oath-toolkit"; exit 1; }

    local age_file="$SECRETS_DIR/totp_bitwarden.age"
    [[ -f "$age_file" ]] || { error "Not found: $age_file"; exit 1; }

    unlock_identity

    local seed
    seed=$(age -d -i "$IDENTITY_KEY" "$age_file" 2>/dev/null) \
        || { error "Failed to decrypt totp_bitwarden.age"; exit 1; }

    oathtool --totp -b "$seed"
}

cmd_list() {
    if [[ ! -f "$MANIFEST" ]]; then
        warn "No manifest found"
        return 0
    fi

    printf '%-20s %-40s %s\n' "NAME" "TARGET" "MODE"
    printf '%-20s %-40s %s\n' "----" "------" "----"

    while IFS=':' read -r name target perms; do
        local age_file="$SECRETS_DIR/$name.age"
        local marker="  "
        [[ ! -f "$age_file" ]] && marker="!!"
        printf '%s %-18s %-40s %s\n' "$marker" "$name" "$target" "$perms"
    done < <(parse_manifest)

    if [[ -f "$SECRETS_DIR/totp_bitwarden.age" ]]; then
        echo
        printf '%-20s\n' "AUTH"
        printf '%-20s\n' "----"
        printf '   %-18s\n' "bitwarden"
    fi
}

# ── Main ────────────────────────────────────────────────────────────────────

usage() {
    cat <<'EOF'
Usage: secrets <command> [args...]

Manage age-encrypted secrets in the dotfiles repo.
Uses recipient-based encryption — passphrase only needed for decryption.

Commands:
    init        Generate passphrase-protected identity (one-time)
    sync        Encrypt all manifest secrets into the repo
    decrypt     Decrypt all secrets to target paths
    auth        Generate Bitwarden 2FA code (emergency, no phone)
    list        Show all secrets and their status
    -h, --help  Show this help

Setup:
    secrets init           # create identity, set passphrase
    secrets sync           # encrypt everything in the manifest

New machine:
    secrets decrypt        # unlock all secrets with passphrase
    secrets auth           # emergency: get Bitwarden 2FA code
EOF
}

main() {
    case "${1:-}" in
        init)       cmd_init ;;
        sync)       cmd_sync ;;
        decrypt)    cmd_decrypt ;;
        auth)       cmd_auth ;;
        list)       cmd_list ;;
        -h|--help)  usage ;;
        "")         usage ;;
        *)          error "Unknown command: $1"; usage; exit 1 ;;
    esac
}

main "$@"
