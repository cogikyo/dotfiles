#!/usr/bin/env bash
set -euo pipefail

mode="term"
refresh=false
search_pattern=""

while [[ "${1:-}" == -* ]]; do
    case "$1" in
        -r) refresh=true; shift ;;
        -s) search_pattern="$2"; shift 2 ;;
        --claude) mode="claude"; shift ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

if [[ -n "$search_pattern" && "$mode" == "term" ]]; then
    _kitty_state=$(kitty @ ls)
    _window_id=$(echo "$_kitty_state" | jq -r '.[0].id')
    if echo "$_kitty_state" | jq -e --arg prefix "${_window_id}-claude-" \
        '.[0].tabs[].windows[0].env.KITTY_TAB_ID | select(. != null and startswith($prefix))' &>/dev/null; then
        mode="claude"
    fi
fi

if [[ "$mode" == "claude" ]]; then
    declare -A TABS=(
        # [xplr]="⊰ 󰭎  ⊱"
        [main]="⊰ 󰯉  ⊱"
        [dev]="⊰   ⊱"
        [idea]="⊰   ⊱"
        [git]="⊰   ⊱"
    )
    declare -A CMDS=(
        # [xplr]='xplr'
        [main]='claude'
        [dev]=''
        [idea]='claude'
        [git]='lazygit'
    )
    declare -A CLAUDE_VARIANTS=(
        [main]='main'
        [dev]='dev'
        [idea]='idea'
    )
    TAB_ORDER=(main dev idea git)
    PREFIX="claude-"
    FOCUS_TAB="master"
    USAGE="kitty-refresh [-r] --claude {master|dev|plan|git|all}"
else
    declare -A TABS=(
        # [xplr]="⟜ 󰭎  ⊸"
        [nvim]="⟜   ⊸"
        [term]="⟜   ⊸"
        [build]="⟜   ⊸"
        [git]="⟜   ⊸"
    )
    declare -A CMDS=(
        [nvim]='nvim'
        [term]=''
        # [xplr]='xplr'
        [build]='just watch'
        [git]='lazygit'
    )
    TAB_ORDER=(nvim term build git)
    PREFIX=""
    FOCUS_TAB="nvim"
    USAGE="kitty-refresh [-r] {nvim|term|xplr|build|git|all}"
fi

kitty_state=$(kitty @ ls)

# Handle -s search mode: parse "term:claude" format and find matching tab
# e.g., "build:plan" means: use "build" in term session OR "plan" in claude session
if [[ -n "$search_pattern" ]]; then
    # Parse term:claude format (e.g., "nvim:master", "build:plan", or just "xplr")
    if [[ "$search_pattern" == *":"* ]]; then
        term_name="${search_pattern%%:*}"
        claude_name="${search_pattern##*:}"
        [[ "$mode" == "claude" ]] && tab_name="$claude_name" || tab_name="$term_name"
    else
        tab_name="$search_pattern"
    fi

    # Check if tab name is valid
    if [[ -z "${TABS[$tab_name]:-}" ]]; then
        echo "Unknown tab: $tab_name"
        echo "Available: ${!TABS[*]}"
        exit 1
    fi

    # Check if that tab actually exists in current session
    expected_title="${TABS[$tab_name]}"
    matched_title=$(echo "$kitty_state" | jq -r --arg title "$expected_title" \
        '.[0].tabs[].title | select(. == $title)' | head -1)

    if [[ -z "$matched_title" ]]; then
        exit 0
    fi

    set -- "$tab_name"
    refresh=true
fi

tab="${1:-}"
[[ -z "$tab" ]] && { echo "Usage: $USAGE"; exit 1; }
[[ "$tab" != "all" && -z "${TABS[$tab]:-}" ]] && { echo "Usage: $USAGE"; exit 1; }
window_id=$(echo "$kitty_state" | jq -r '.[0].id')
cwd=$(echo "$kitty_state" | jq -r '.[0].tabs[] | select(.is_focused) | .windows[] | select(.is_focused) | .cwd')

# Fallback to PWD if cwd is empty or home
if [[ -z "$cwd" || "$cwd" == "$HOME" ]]; then
    cwd="${PWD:-$HOME}"
fi

get_tab_index() {
    local name="$1"
    local tab_id="${window_id}-${PREFIX}${name}"
    kitty @ ls | jq -r --arg id "$tab_id" '.[0].tabs | to_entries[] | select(.value.windows[0].env.KITTY_TAB_ID == $id) | .key'
}

open_tab() {
    local name="$1"
    local tab_id="${window_id}-${PREFIX}${name}"
    local title="${TABS[$name]}"
    local cmd="${CMDS[$name]}"

    if [[ "$name" == "build" ]]; then
        just --list --justfile "$cwd/justfile" &>/dev/null || { "$refresh" && kitty @ close-tab --match "env:KITTY_TAB_ID=${tab_id}" 2>/dev/null || true; return 0; }
    fi

    if [[ "$name" == "git" ]]; then
        git -C "$cwd" rev-parse --git-dir &>/dev/null || { "$refresh" && kitty @ close-tab --match "env:KITTY_TAB_ID=${tab_id}" 2>/dev/null || true; return 0; }
    fi

    "$refresh" && kitty @ close-tab --match "env:KITTY_TAB_ID=${tab_id}" 2>/dev/null || true

    local env_args=(--env KITTY_TAB_ID="$tab_id")

    if [[ -n "$cmd" ]]; then
        kitty @ launch --type=tab --hold --copy-env "${env_args[@]}" --tab-title="$title" --cwd="$cwd" "$cmd" >/dev/null
    else
        kitty @ launch --type=tab --copy-env "${env_args[@]}" --tab-title="$title" --cwd="$cwd" >/dev/null
    fi
}

close_launcher_tab() {
    # Close the initial launcher tab (has no KITTY_TAB_ID env var)
    local launcher_tab_id
    launcher_tab_id=$(kitty @ ls | jq -r '.[0].tabs[] | select(.windows[0].env.KITTY_TAB_ID == null or .windows[0].env.KITTY_TAB_ID == "") | .id' | head -1)
    [[ -n "$launcher_tab_id" ]] && kitty @ close-tab --match "id:${launcher_tab_id}" 2>/dev/null || true
}

if [[ "$tab" == "all" ]]; then
    for name in "${TAB_ORDER[@]}"; do
        open_tab "$name"
    done
    close_launcher_tab
    kitty @ focus-tab --match "env:KITTY_TAB_ID=${window_id}-${PREFIX}${FOCUS_TAB}" 2>/dev/null || true
else
    kitty @ focus-tab --match "env:KITTY_TAB_ID=${window_id}-${PREFIX}${tab}" 2>/dev/null || true
    original_idx=$(get_tab_index "$tab")
    open_tab "$tab"
    new_idx=$(get_tab_index "$tab")
    if [[ -n "$original_idx" && -n "$new_idx" && "$new_idx" -gt "$original_idx" ]]; then
        moves=$((new_idx - original_idx))
        for ((i=0; i<moves; i++)); do
            kitty @ action move_tab_backward
        done
    fi
fi
