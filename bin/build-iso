#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
#  Custom Arch ISO Builder
#
#  Builds a live ISO with all repo + AUR packages pre-cached in a [localrepo],
#  so archinstall resolves from local disk instead of downloading.
#
#  Usage: sudo build-iso [--usb /dev/sdX] [--skip-aur] [--clean] [--release]
# =============================================================================

VERSION="0.1.0"

# -- paths --------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
DOTFILES="$(cd "$SCRIPT_DIR/.." && pwd)"
ISO_DIR="$DOTFILES/iso"
WORK_DIR="$ISO_DIR/work"
OUT_DIR="$ISO_DIR/out"

PACKAGES_LST="$DOTFILES/etc/packages.lst"
PACKAGES_AUR_LST="$DOTFILES/etc/packages-aur.lst"

LOCALREPO_DIR=""  # set in prepare_profile

# -- options ------------------------------------------------------------------

USB_DEVICE=""
SKIP_AUR=0
CLEAN=0
RELEASE=0

# -- colors -------------------------------------------------------------------

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
FAINT='\033[90m'
BOLD='\033[1m'
RESET='\033[0m'

if [[ ! -t 1 || -n "${NO_COLOR:-}" ]]; then
    RED='' GREEN='' YELLOW='' BLUE='' FAINT='' BOLD='' RESET=''
fi

_log() {
    local color="$1" prefix="$2"; shift 2
    printf '%b%s%b %s\n' "$color" "$prefix" "$RESET" "$*"
}

info()  { _log "$BLUE"   "[INFO]"  "$*"; }
ok()    { _log "$GREEN"  "[OK]"    "$*"; }
warn()  { _log "$YELLOW" "[WARN]"  "$*"; }
err()   { _log "$RED"    "[ERROR]"  "$*" >&2; }
die()   { err "$*"; exit 1; }
phase() { printf '\n%b=== Phase %s ===%b\n\n' "$BOLD" "$*" "$RESET"; }

# -- usage --------------------------------------------------------------------

usage() {
    cat <<EOF
Usage: sudo build-iso [OPTIONS]

Build a custom Arch Linux ISO with pre-cached packages.

Options:
  --usb /dev/sdX   Write ISO to USB device after build
  --skip-aur       Skip AUR package builds
  --clean          Remove work/out dirs before building
  --release        Tag, push, and create a GitHub release with the ISO
  -h, --help       Show this help

Version: $VERSION
EOF
}

# -- helpers ------------------------------------------------------------------

read_package_list() {
    local file="$1"
    [[ -f "$file" ]] || return 0
    grep -v '^#\|^$' "$file" | sed 's/#.*//' | awk '{print $1}' | sort -u
}

# =============================================================================
#  Phase 0: Preflight
# =============================================================================

preflight() {
    phase "0: Preflight"

    [[ $EUID -eq 0 ]] || die "Must be run as root (use sudo)"

    local missing=()
    for cmd in mkarchiso pacman makepkg repo-add git; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        die "Missing required commands: ${missing[*]}
Install archiso: pacman -S archiso"
    fi

    [[ -d "$ISO_DIR" ]] || die "ISO profile not found: $ISO_DIR"
    [[ -f "$PACKAGES_LST" ]] || die "Package list not found: $PACKAGES_LST"

    local repo_count aur_count
    repo_count=$(read_package_list "$PACKAGES_LST" | wc -l)
    aur_count=0
    [[ -f "$PACKAGES_AUR_LST" ]] && aur_count=$(read_package_list "$PACKAGES_AUR_LST" | wc -l)

    info "Dotfiles:      $DOTFILES"
    info "ISO profile:   $ISO_DIR"
    info "Repo packages: $repo_count"
    info "AUR packages:  $aur_count"

    if [[ -n "$USB_DEVICE" ]]; then
        [[ -b "$USB_DEVICE" ]] || die "USB device not found: $USB_DEVICE"
        info "USB target:    $USB_DEVICE"
    fi
}

# =============================================================================
#  Phase 1: Prepare profile
# =============================================================================

prepare_profile() {
    phase "1: Prepare profile"

    if [[ $CLEAN -eq 1 ]]; then
        info "Cleaning previous build artifacts..."
        rm -rf "$WORK_DIR" "$OUT_DIR"
    fi

    mkdir -p "$WORK_DIR" "$OUT_DIR"

    # localrepo lives inside the airootfs so it ends up in the squashfs
    LOCALREPO_DIR="$ISO_DIR/airootfs/var/cache/localrepo"
    mkdir -p "$LOCALREPO_DIR"

    # Copy dotfiles repo into the live environment
    local airootfs_dotfiles="$ISO_DIR/airootfs/root/dotfiles"
    if [[ -d "$airootfs_dotfiles" ]]; then
        info "Updating dotfiles in airootfs..."
        rm -rf "$airootfs_dotfiles"
    fi

    info "Copying dotfiles repo into airootfs/root/dotfiles..."
    mkdir -p "$airootfs_dotfiles"
    tar -C "$DOTFILES" \
        --exclude='./iso/work' \
        --exclude='./iso/out' \
        --exclude='./iso/airootfs/var' \
        --exclude='./iso/airootfs/root/dotfiles' \
        --exclude='./.git' \
        -cf - . | tar -xf - -C "$airootfs_dotfiles"

    # NOTE: mkarchiso uses cp --no-preserve=mode, so chmod here has no effect.
    # Execute bits are restored in .zlogin on first login instead.

    ok "Dotfiles copied to live environment"
}

# =============================================================================
#  Phase 2: Cache repo packages
# =============================================================================

cache_repo_packages() {
    phase "2: Cache repo packages"

    # Collect all repo packages: archinstall essentials + packages.lst
    local -a pkgs=()

    # Base packages that archinstall needs
    local base_pkgs=(base linux linux-firmware base-devel git networkmanager)
    for pkg in "${base_pkgs[@]}"; do
        pkgs+=("$pkg")
    done

    # Read from packages.lst
    while IFS= read -r pkg; do
        pkgs+=("$pkg")
    done < <(read_package_list "$PACKAGES_LST")

    # Deduplicate
    local -a unique_pkgs=()
    local seen=""
    for pkg in "${pkgs[@]}"; do
        if [[ "$seen" != *"|$pkg|"* ]]; then
            unique_pkgs+=("$pkg")
            seen+="|$pkg|"
        fi
    done

    info "Downloading ${#unique_pkgs[@]} packages (+ dependencies) to localrepo..."

    # Download packages without installing — pacman -Syw downloads to cachedir
    # Use --noconfirm and ignore groups that would prompt
    pacman -Syw --noconfirm --needed \
        --cachedir "$LOCALREPO_DIR" \
        --dbpath /var/lib/pacman \
        "${unique_pkgs[@]}" || {
        warn "Some packages may not exist in repos (AUR packages are handled in phase 3)"
        # Retry with only packages that exist in sync dbs
        local -a valid_pkgs=()
        for pkg in "${unique_pkgs[@]}"; do
            if pacman -Si "$pkg" &>/dev/null; then
                valid_pkgs+=("$pkg")
            else
                warn "Skipping non-repo package: $pkg"
            fi
        done
        if [[ ${#valid_pkgs[@]} -gt 0 ]]; then
            pacman -Syw --noconfirm --needed \
                --cachedir "$LOCALREPO_DIR" \
                --dbpath /var/lib/pacman \
                "${valid_pkgs[@]}"
        fi
    }

    local count
    count=$(find "$LOCALREPO_DIR" -name '*.pkg.tar.*' ! -name '*.sig' | wc -l)
    ok "Downloaded $count packages to localrepo"
}

# =============================================================================
#  Phase 3: Build AUR packages
# =============================================================================

build_aur_packages() {
    phase "3: Build AUR packages"

    if [[ $SKIP_AUR -eq 1 ]]; then
        warn "Skipping AUR builds (--skip-aur)"
        return 0
    fi

    if [[ ! -f "$PACKAGES_AUR_LST" ]]; then
        info "No AUR package list found, skipping"
        return 0
    fi

    local -a aur_pkgs=()
    while IFS= read -r pkg; do
        aur_pkgs+=("$pkg")
    done < <(read_package_list "$PACKAGES_AUR_LST")

    if [[ ${#aur_pkgs[@]} -eq 0 ]]; then
        info "No AUR packages to build"
        return 0
    fi

    # Create a temporary build user since makepkg refuses to run as root
    local build_user="_isobuild"
    local build_home="/tmp/_isobuild"

    if ! id "$build_user" &>/dev/null; then
        useradd -m -d "$build_home" -s /bin/bash "$build_user"
        # Allow passwordless sudo for package installation during makepkg -s
        echo "$build_user ALL=(ALL) NOPASSWD: ALL" > "/etc/sudoers.d/$build_user"
    fi
    mkdir -p "$build_home"
    chown -R "$build_user:$build_user" "$build_home"

    # Ensure common build deps that PKGBUILDs often omit
    info "Installing common build dependencies..."
    pacman -S --noconfirm --needed perl 2>/dev/null || true

    # Ensure rustup has a default toolchain for the build user
    if command -v rustup &>/dev/null; then
        sudo -u "$build_user" env RUSTUP_HOME="$build_home/.rustup" CARGO_HOME="$build_home/.cargo" \
            rustup default stable 2>/dev/null || true
    fi

    local built=0 failed=0 skipped=0
    info "Building ${#aur_pkgs[@]} AUR packages..."

    for pkg in "${aur_pkgs[@]}"; do
        # Skip if we already have this package cached
        if find "$LOCALREPO_DIR" -name "${pkg}-*.pkg.tar.*" ! -name '*.sig' | grep -q .; then
            ((++skipped))
            continue
        fi

        local build_dir="$build_home/$pkg"
        rm -rf "$build_dir"

        info "Building AUR: $pkg"
        if ! sudo -u "$build_user" git clone --depth 1 "https://aur.archlinux.org/$pkg.git" "$build_dir" 2>/dev/null; then
            err "Failed to clone AUR package: $pkg"
            ((++failed))
            continue
        fi

        if sudo -u "$build_user" env RUSTUP_HOME="$build_home/.rustup" CARGO_HOME="$build_home/.cargo" PATH="$build_home/.cargo/bin:/usr/bin/core_perl:$PATH" \
            bash -c "cd '$build_dir' && makepkg -s --noconfirm --noprogressbar 2>&1"; then
            # Copy built packages to localrepo
            local found_pkg=0
            while IFS= read -r -d '' pkg_file; do
                cp "$pkg_file" "$LOCALREPO_DIR/"
                ((++found_pkg))
            done < <(find "$build_dir" -name '*.pkg.tar.*' ! -name '*.sig' -print0)

            if [[ $found_pkg -gt 0 ]]; then
                ((++built))
                ok "Built: $pkg"
            else
                err "No package file produced for: $pkg"
                ((++failed))
            fi
        else
            err "Failed to build: $pkg"
            ((++failed))
        fi

        rm -rf "$build_dir"
    done

    # Cleanup build user
    userdel -r "$build_user" 2>/dev/null || true
    rm -f "/etc/sudoers.d/$build_user"

    ok "AUR builds complete: $built built, $skipped cached, $failed failed"
    [[ $failed -eq 0 ]] || warn "Some AUR packages failed to build — install will fall back to network"
}

# =============================================================================
#  Phase 4: Create repo database
# =============================================================================

create_repo_db() {
    phase "4: Create repo database"

    local pkg_count
    pkg_count=$(find "$LOCALREPO_DIR" -name '*.pkg.tar.*' ! -name '*.sig' | wc -l)

    if [[ $pkg_count -eq 0 ]]; then
        die "No packages found in localrepo — nothing to index"
    fi

    info "Creating repo database for $pkg_count packages..."

    # Remove old db files
    rm -f "$LOCALREPO_DIR"/localrepo.db* "$LOCALREPO_DIR"/localrepo.files*

    # Create the repo database (use find to avoid glob failures when a format is absent)
    find "$LOCALREPO_DIR" -name '*.pkg.tar.*' ! -name '*.sig' -exec \
        repo-add "$LOCALREPO_DIR/localrepo.db.tar.zst" {} +

    ok "Repo database created"
}

# =============================================================================
#  Phase 5: Build ISO
# =============================================================================

build_iso() {
    phase "5: Build ISO"

    info "Building ISO with mkarchiso..."
    info "This may take a while..."

    mkarchiso -v -w "$WORK_DIR" -o "$OUT_DIR" "$ISO_DIR"

    local iso_file
    iso_file=$(find "$OUT_DIR" -name '*.iso' -printf '%T@ %p\n' | sort -rn | head -1 | cut -d' ' -f2-)

    if [[ -z "$iso_file" ]]; then
        die "ISO build failed — no .iso file found in $OUT_DIR"
    fi

    local iso_size
    iso_size=$(du -h "$iso_file" | cut -f1)
    ok "ISO built: $iso_file ($iso_size)"
}

# =============================================================================
#  Phase 6: Write to USB
# =============================================================================

write_to_usb() {
    phase "6: Write to USB"

    if [[ -z "$USB_DEVICE" ]]; then
        info "No --usb specified, skipping USB write"
        return 0
    fi

    local iso_file
    iso_file=$(find "$OUT_DIR" -name '*.iso' -printf '%T@ %p\n' | sort -rn | head -1 | cut -d' ' -f2-)

    [[ -n "$iso_file" ]] || die "No ISO file found to write"
    [[ -b "$USB_DEVICE" ]] || die "USB device not found: $USB_DEVICE"

    # Safety check — make sure it's not a mounted filesystem
    if findmnt "$USB_DEVICE" &>/dev/null || findmnt "${USB_DEVICE}"?* &>/dev/null 2>&1; then
        die "USB device $USB_DEVICE (or a partition) is mounted — unmount first"
    fi

    local iso_size dev_size
    iso_size=$(stat -c %s "$iso_file")
    dev_size=$(blockdev --getsize64 "$USB_DEVICE")

    if [[ $iso_size -gt $dev_size ]]; then
        die "ISO ($iso_size bytes) is larger than device ($dev_size bytes)"
    fi

    warn "This will ERASE ALL DATA on $USB_DEVICE"
    printf '%b  ?  %b Continue? %b[y/N]%b ' '\033[0;35m' '\033[0m' '\033[90m' '\033[0m'
    local yn
    read -r yn
    [[ "$yn" =~ ^[Yy] ]] || { info "Aborted"; return 0; }

    info "Writing ISO to $USB_DEVICE..."
    dd bs=4M if="$iso_file" of="$USB_DEVICE" status=progress oflag=sync

    ok "ISO written to $USB_DEVICE"
    info "You can now boot from this USB drive"
}

# =============================================================================
#  Phase 7: GitHub Release
# =============================================================================

publish_release() {
    phase "7: GitHub Release"

    if [[ $RELEASE -eq 0 ]]; then
        info "No --release specified, skipping"
        return 0
    fi

    local iso_file
    iso_file=$(find "$OUT_DIR" -name '*.iso' -printf '%T@ %p\n' | sort -rn | head -1 | cut -d' ' -f2-)
    [[ -n "$iso_file" ]] || die "No ISO file found to release"

    # Git/gh must run as the invoking user, not root
    local run_user="${SUDO_USER:-$USER}"
    local run_home
    run_home=$(eval echo "~$run_user")

    _as_user() {
        sudo -u "$run_user" --preserve-env=HOME,XDG_CONFIG_HOME,GH_TOKEN \
            env HOME="$run_home" "$@"
    }

    # Preflight checks
    command -v gh &>/dev/null || die "gh CLI not installed (pacman -S github-cli)"
    _as_user gh auth status &>/dev/null || die "gh not authenticated — run: gh auth login"

    local branch
    branch=$(_as_user git -C "$DOTFILES" branch --show-current)
    [[ "$branch" == "master" ]] || die "Not on master branch (on: $branch)"

    # Suggest a tag based on the ISO filename date
    local iso_name
    iso_name=$(basename "$iso_file")
    local default_tag="iso-$(echo "$iso_name" | grep -oP '\d{4}\.\d{2}\.\d{2}')"
    [[ -n "$default_tag" && "$default_tag" != "iso-" ]] || default_tag="iso-$(date +%Y.%m.%d)"

    printf '\n%b  ?  %b Release tag %b[%s]%b: ' '\033[0;35m' '\033[0m' "$FAINT" "$default_tag" "$RESET"
    local tag
    read -r tag
    tag="${tag:-$default_tag}"

    # Validate tag doesn't already exist
    if _as_user git -C "$DOTFILES" rev-parse "refs/tags/$tag" &>/dev/null; then
        die "Tag '$tag' already exists"
    fi

    # Commit any staged/unstaged changes
    if ! _as_user git -C "$DOTFILES" diff --quiet HEAD 2>/dev/null || \
       [[ -n "$(_as_user git -C "$DOTFILES" ls-files --others --exclude-standard)" ]]; then
        info "Committing pending changes..."
        _as_user git -C "$DOTFILES" add -A
        _as_user git -C "$DOTFILES" commit -m "chore: $tag"
    fi

    # Tag + push
    info "Creating tag: $tag"
    _as_user git -C "$DOTFILES" tag -a "$tag" -m "$tag"

    info "Pushing master + tag to origin..."
    _as_user git -C "$DOTFILES" push origin master
    _as_user git -C "$DOTFILES" push origin "$tag"

    # Create GitHub release with ISO attached
    local iso_size
    iso_size=$(du -h "$iso_file" | cut -f1)

    info "Creating GitHub release (uploading $iso_size ISO — this may take a while)..."
    _as_user gh release create "$tag" \
        --repo "$(_as_user git -C "$DOTFILES" remote get-url origin)" \
        --title "$tag" \
        --notes "Custom Arch Linux ISO with pre-cached packages (repo + AUR).

Built with \`build-iso v$VERSION\` — includes dotfiles, localrepo, and archinstall auto-configuration.

**ISO:** \`$iso_name\` ($iso_size)" \
        "$iso_file"

    ok "Release published: $tag"
}

# =============================================================================
#  Main
# =============================================================================

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --usb)
                [[ -n "${2:-}" ]] || die "--usb requires a device argument"
                USB_DEVICE="$2"
                shift 2
                ;;
            --skip-aur)
                SKIP_AUR=1
                shift
                ;;
            --clean)
                CLEAN=1
                shift
                ;;
            --release)
                RELEASE=1
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done

    echo
    printf '%b%s%b\n' "$BOLD" "build-iso v$VERSION" "$RESET"
    printf '%b%s%b\n' "$FAINT" "Custom Arch ISO with pre-cached packages" "$RESET"
    echo

    preflight
    prepare_profile
    cache_repo_packages
    build_aur_packages
    create_repo_db
    build_iso
    write_to_usb
    publish_release

    local iso_path
    iso_path=$(find "$OUT_DIR" -name '*.iso' -printf '%T@ %p\n' | sort -rn | head -1 | cut -d' ' -f2-)

    echo
    ok "All done!"
    echo
    info "Test in QEMU:"
    printf '%b  %s%b\n' "$FAINT" "qemu-img create -f qcow2 /tmp/test-disk.qcow2 40G && \\" "$RESET"
    printf '%b  %s%b\n' "$FAINT" "qemu-system-x86_64 -cdrom $iso_path \\" "$RESET"
    printf '%b  %s%b\n' "$FAINT" "  -m 8G -smp 4 -enable-kvm -display gtk \\" "$RESET"
    printf '%b  %s%b\n' "$FAINT" "  -drive file=/tmp/test-disk.qcow2,format=qcow2,if=virtio" "$RESET"
    echo
}

main "$@"
